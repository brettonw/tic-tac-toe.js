<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="icon.png?1"/>
    <link rel="stylesheet" href="https://bedrock.brettonw.com/dist/latest/bedrock.css" />
    <link rel="stylesheet" href="test.css" />
    <title>Tic-Tac-Toe</title>
</head>
<body id="parent">
</body>
</html>

<script src="https://bedrock.brettonw.com/dist/latest/bedrock-debug.js"></script>
<script>let Enum = Bedrock.Enum; </script>
<script src="src/main/js/tic-tac-toe.js"></script>
<script src="src/test/js/test-harness.js"></script>
<script src="src/test/js/tic-tac-toe.js"></script>

<script>
    let Builder = Bedrock.Html.Builder;

    let SvgTransformer = function () {
        let _ = Object.create(Bedrock.Base);

        // generate a bunch of zoom steps for zooming smoothly, this uses a
        // quadratic curve for a perceptually linear progression. The values are
        // scaled so that we start with a zoom factor at exactly 1.0
        let rangeMin = 0.0125;
        let rangeMax = 2.0;
        let steps = 33;
        let viewScale1 = Math.round (Math.sqrt ((1 - rangeMin) / rangeMax) * steps);
        let viewScaleNormalizer = viewScale1 / steps;
        viewScaleNormalizer = rangeMin + ((viewScaleNormalizer * viewScaleNormalizer) * rangeMax)
        let viewScales = [];
        for (let i = 0; i <= steps; ++i) {
            let delta = i / steps;
            let viewScale = (rangeMin + ((delta * delta) * rangeMax)) / viewScaleNormalizer;
            viewScales.push (viewScale);
        }

        _.init = function (parameters) {
            this.parentId = parameters.parentId;
            this.view = parameters.view;
            this.rootScale = parameters.rootScale;
            this.x = 0;
            this.y = 0;
            this.si = viewScale1;
            this.mouseDownEvent = null;
            return this;
        };

        _.setTransform = function () {
            this.view.setAttribute ("transform", "translate(" + this.x + "," + this.y + ") scale(" + viewScales[this.si] + ")");
            document.getElementById(this.parentId + "-zoom-div").innerText = viewScales[this.si].toFixed (4) + "X";
        };

        _.handleSvgMouseDown = function (event) {
            this.mouseDownEvent = event;
            this.oldX = this.x;
            this.oldY = this.y;
            console.log ("down");
        };

        _.handleSvgMouseUp = function (event) {
            this.mouseDownEvent = null;
            console.log ("up");
        };

        _.handleSvgMouseMove = function (event) {
            if (this.mouseDownEvent !== null) {
                console.log ("move");
                this.x = this.oldX + ((event.clientX - this.mouseDownEvent.clientX) / this.rootScale);
                this.y = this.oldY + ((event.clientY - this.mouseDownEvent.clientY) / this.rootScale);
                this.setTransform ();
            }
        };

        _.enabled = true;
        _.handleSvgWheel = function (event) {
            if (this.enabled == true) {
                this.enabled = false;
                // chrome and firefox have got to be different...
                let deltaY = (event.wheelDeltaY !== undefined) ? event.wheelDeltaY : -event.deltaY;
                if (Math.abs (deltaY) > 0) {
                    //console.log ("wheel - " + deltaY);
                    this.si = Math.max (0, Math.min (viewScales.length - 1, this.si + (deltaY / Math.abs (deltaY))));
                    this.setTransform ();
                }

                let that = this;
                setTimeout (function () {
                    that.enabled = true;
                }, 1000 / 60);
            }
            return false;
        };

        return _;
    } ();


    let addSvg = function (parent) {
        let fixedUpperLeft = { position: "absolute", top: 0, left: 0 };
        let divRoot = Builder
            .begin ("div", { style: { position: "relative", width: "100%", height: "100%" } })
            .begin ("http://www.w3.org/2000/svg;svg", {
                id: parent.id + "-svg-root",
                attributes: { width: "100%", height: "100%" },
                style: fixedUpperLeft
            })
            .begin ("http://www.w3.org/2000/svg;g", { id: parent.id + "-root-g" })
            .begin ("http://www.w3.org/2000/svg;g", { id: parent.id + "-view-g" })
            .add ("http://www.w3.org/2000/svg;g", {
                id: parent.id + "-client-g",
                attribute: { transform: "scale (1, -1)" }
            })
            .end ()
            .end ()
            .end ()
            .begin("div", { style: fixedUpperLeft })
            .add ("div", { id: parent.id + "-zoom-div", style: { padding: "1px 3px" } })
            .end ()
            .end ();
        parent.appendChild (divRoot);

        let svgRoot = document.getElementById (parent.id + "-svg-root");
        let rootG = document.getElementById (parent.id + "-root-g");
        let viewG = document.getElementById (parent.id + "-view-g");
        let clientG = document.getElementById (parent.id + "-client-g");
        viewG.appendChild(clientG);

        // add event handlers
        svgRoot.addEventListener("mousedown", function (event) { this.svgTransformer.handleSvgMouseDown (event); }, false);
        svgRoot.addEventListener("mouseup", function (event) { this.svgTransformer.handleSvgMouseUp (event); }, false);
        svgRoot.addEventListener("mousemove", function (event) { this.svgTransformer.handleSvgMouseMove (event); }, false);
        svgRoot.addEventListener("wheel", function (event) { this.svgTransformer.handleSvgWheel (event); }, false);

        // set up the view scales
        let bound = svgRoot.getBoundingClientRect ();
        let rootScale = Math.min (bound.width, bound.height);
        let translateX = bound.width / (2 * rootScale);
        let translateY = bound.height / (2 * rootScale);
        rootG.setAttribute ("transform", "scale(" + rootScale + ") translate(" + translateX + "," + translateY + ")");

        // create a transformer object to manipulate the view
        svgRoot.svgTransformer = SvgTransformer.new ({ parentId: parent.id, view: viewG, rootScale: rootScale });
        svgRoot.svgTransformer.setTransform();
        return clientG;
    };

    let parent = document.getElementById("parent");
    let svgClient = addSvg(parent);

    let makeLine = function (container, a, b, color, alpha, width) {
        container.appendChild(Builder
            .add ("http://www.w3.org/2000/svg;line", {
                attributes: {
                    "x1": a.x, "y1": a.y,
                    "x2": b.x, "y2": b.y,
                    "stroke": color,
                    "opacity": alpha,
                    "stroke-width": width,
                    "stroke-linecap":"round"
                }
            }));
    };

    let drawPath = function (container, points, color, alpha, width) {
        let lastPos = points[0];
        for (let i = 1; i < points.length; ++i) {
            let pos = points[i];
            makeLine (container, lastPos, pos, color, alpha, width);
            lastPos = pos;
        }
    };

    let makePerturbedPath = function (container, points, color, alpha, width, perturbDelta) {
        let perturbPoint = function (pt) {
            return {
                x: pt.x + (((Math.random () * 2) - 1) * perturbDelta),
                y:pt.y + (((Math.random () * 2) - 1) * perturbDelta)
            };
        };
        // randomly perturb each of the points
        let perturbedPoints = [];
        for (let point of points) {
            perturbedPoints.push (perturbPoint(point));
        }
        drawPath(container, perturbedPoints, color, alpha, width);
    };

    let makeWiggleLine= function (container, a, b, color, alpha, width, perturbDelta, parts) {
        // split the line into parts
        let delta = { x: b.x - a.x, y: b.y - a.y };
        let deltaLength = Math.sqrt ((delta.x * delta.x) + (delta.y * delta.y));
        let points = [a];

        for (let i = 1; i < parts; ++i) {
            let d = deltaLength * (i / parts);
            let point = { x: a.x + (d * delta.x), y: a.y + (d * delta.y)};
            points.push(point);
        }
        points.push(b);
        makePerturbedPath(container, points, color, alpha, width, perturbDelta);
    };

    // make graph paper, 100x100 grid
    let gridG = Builder.add ("http://www.w3.org/2000/svg;g");
    let gridAlpha = 0.25;
    let gridWeight = 0.0025;
    makeLine (gridG, {x: -1, y: 0}, {x: 1, y: 0}, "#00f", gridAlpha * 2, gridWeight * 2);
    makeLine (gridG, {x: 0, y: -1}, {x: 0, y: 1}, "#00f", gridAlpha * 2, gridWeight * 2);
    let gridSize = 50;
    for (let i = 1; i <= gridSize; ++i) {
        let val = i / gridSize;
        makeLine (gridG, {x: -1, y: val}, {x: 1, y: val}, "#08f", gridAlpha, gridWeight);
        makeLine (gridG, {x: -1, y: -val}, {x: 1, y: -val}, "#08f", gridAlpha, gridWeight);
        makeLine (gridG, {x: val, y: -1}, {x: val, y: 1}, "#08f", gridAlpha, gridWeight);
        makeLine (gridG, {x: -val, y: -1}, {x: -val, y: 1}, "#08f", gridAlpha, gridWeight);
    }
    //svgClient.appendChild(gridG);

    let drawMove = function (container, scale, move, drawInto) {
        let y = (Board.DIMENSION - 1) - move.y ();
        let xG = Builder.add ("http://www.w3.org/2000/svg;g", { attribute: {
                transform: "translate(" + (move.x () / 3) + "," + (y / 3) + ") scale (" + (1 / 3) + ")"
            } });
        drawInto (xG);
        container.appendChild (xG);
    };

    let drawX = function (container, scale, move) {
        drawMove (container, scale, move, function (xG) {
            makeWiggleLine (xG, { x: 0.25, y: 0.25 }, { x: 0.75, y: 0.75 }, "red", 1.0, 0.075, 0.025, 4);
            makeWiggleLine (xG, { x: 0.25, y: 0.75 }, { x: 0.75, y: 0.25 }, "red", 1.0, 0.075, 0.025, 4);

        });
    };

    Math.TWO_PI = Math.PI * 2;
    let drawO = function (container, scale, move) {
        drawMove (container, scale, move, function (xG) {
            let posFromAngle = function (angle) {
                return { x: (Math.cos(angle) / 4) + 0.5, y: (Math.sin (angle) / 4) + 0.5 };
            };
            let segmentCount = 14;
            let segmentAngle = Math.TWO_PI / segmentCount;
            let startAngle = Math.TWO_PI * Math.random();
            let points = [];
            for (let i = 0; i <= segmentCount; ++i) {
                let pos = posFromAngle(startAngle + (segmentAngle * (i % segmentCount)));
                points.push (pos);
            }
            makePerturbedPath (xG, points, "red", 1.0, 0.075, 0.02);
        });
    };

    let drawBoard = function (container, board, scale, location) {
        let boardG = Builder.add ("http://www.w3.org/2000/svg;g", { attribute: {
            transform: "translate(" + location.x + "," + location.y + ") scale (" + scale + ")"
        } });
        makeWiggleLine (boardG, { x: 0, y: 0.333 }, { x: 1, y: 0.333 }, "black", 1.0, 0.05, 0.02, 8);
        makeWiggleLine (boardG, { x: 0, y: 0.667 }, { x: 1, y: 0.667 }, "black", 1.0, 0.05, 0.02, 8);
        makeWiggleLine (boardG, { x: 0.333, y: 0 }, { x: 0.333, y: 1 }, "black", 1.0, 0.05, 0.02, 8);
        makeWiggleLine (boardG, { x: 0.667, y: 0 }, { x: 0.667, y: 1 }, "black", 1.0, 0.05, 0.02, 8);

        // now add the board positions
        for (let row = 0; row < Board.DIMENSION; ++row) {
            for (let col = 0; col < Board.DIMENSION; ++col) {
                let move = Move.get (col, row);
                let player = board.getPlayer (move);
                switch (player) {
                    case Player.X:
                        drawX (boardG, scale, move);
                        break;
                    case Player.O:
                        drawO (boardG, scale, move);
                        break;
                    default:
                        break;
                }
            }
        }

        container.appendChild (boardG);
    };

    let wins = Referee.getWins();
    let halfWins = wins.length / 2;
    let size = 0.15;
    let spacingScale = 1.5;
    let spacing = size * spacingScale;
    for (let i = 0; i < halfWins; ++i) {
        drawBoard (svgClient, Board.fromString (wins[i]), size, { x: -1 + (i * spacing), y: 0 });
        drawBoard (svgClient, Board.fromString (wins[i + halfWins]), size, { x: -1 + (i *spacing), y: spacing });
    }

    /*
    svgClient.appendChild(Builder
        .add ("http://www.w3.org/2000/svg;circle", {
            attributes: {
                "cx": 0, "cy": 0,
                "r": 0.5,
                "stroke": "black",
                "stroke-width": 0.1,
                "fill": "yellow"
            }
        })
    );
    */


</script>
