<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="icon.png?1"/>
    <link rel="stylesheet" href="https://bedrock.brettonw.com/dist/latest/bedrock.css" />
    <link rel="stylesheet" href="test.css" />
    <title>Tic-Tac-Toe</title>
</head>
<body id="parent">
</body>
</html>

<script src="https://bedrock.brettonw.com/dist/latest/bedrock-debug.js"></script>
<script>let Enum = Bedrock.Enum; </script>
<script src="src/main/js/tic-tac-toe.js"></script>
<script src="src/test/js/test-harness.js"></script>
<script src="src/test/js/tic-tac-toe.js"></script>

<script>
    let Builder = Bedrock.Html.Builder;

    let SvgTransformer = function () {
        let _ = Object.create(Bedrock.Base);

        // generate a bunch of zoom steps for zooming smoothly, this uses a
        // quadratic curve for a perceptually linear progression. The values are
        // scaled so that we start with a zoom factor at exactly 1.0
        let rangeMin = 0.125;
        let rangeMax = 8.0;
        let steps = 64;
        let viewScale1 = Math.round (Math.sqrt ((1 - rangeMin) / rangeMax) * steps);
        let viewScaleNormalizer = viewScale1 / steps;
        viewScaleNormalizer = rangeMin + ((viewScaleNormalizer * viewScaleNormalizer) * rangeMax)
        let viewScales = [];
        for (let i = 0; i <= steps; ++i) {
            let delta = i / steps;
            let viewScale = (rangeMin + ((delta * delta) * rangeMax)) / viewScaleNormalizer;
            viewScales.push (viewScale);
        }

        _.init = function (parameters) {
            this.parentId = parameters.parentId;
            this.view = parameters.view;
            this.rootScale = parameters.rootScale;
            this.x = 0;
            this.y = 0;
            this.si = viewScale1;
            this.mouseDownEvent = null;
            return this;
        };

        _.setTransform = function () {
            this.view.setAttribute ("transform", "translate(" + this.x + "," + this.y + ") scale(" + viewScales[this.si] + ")");
            document.getElementById(this.parentId + "-zoom-div").innerText = viewScales[this.si].toFixed (4) + "X";
        };

        _.handleSvgMouseDown = function (event) {
            this.mouseDownEvent = event;
            this.oldX = this.x;
            this.oldY = this.y;
            //console.log ("down");
        };

        _.handleSvgMouseUp = function (event) {
            this.mouseDownEvent = null;
            //console.log ("up");
        };

        _.handleSvgMouseMove = function (event) {
            if (this.mouseDownEvent !== null) {
                //console.log ("move");
                this.x = this.oldX + ((event.clientX - this.mouseDownEvent.clientX) / this.rootScale);
                this.y = this.oldY + ((event.clientY - this.mouseDownEvent.clientY) / this.rootScale);
                this.setTransform ();
            }
        };

        _.enabled = true;
        _.handleSvgWheel = function (event) {
            if (this.enabled == true) {
                this.enabled = false;
                // chrome and firefox have got to be different...
                let deltaY = (event.wheelDeltaY !== undefined) ? event.wheelDeltaY : -event.deltaY;
                if (Math.abs (deltaY) > 0) {
                    //console.log ("wheel - " + deltaY);
                    let oldS = viewScales[this.si];
                    let oldX = this.x;
                    let oldY = this.y;

                    this.si = Math.max (0, Math.min (viewScales.length - 1, this.si + (deltaY / Math.abs (deltaY))));
                    let newS = viewScales[this.si];

                    this.x = oldX * newS / oldS;
                    this.y = oldY * newS / oldS;

                    this.setTransform ();
                }

                let that = this;
                setTimeout (function () {
                    that.enabled = true;
                }, 1000 / 60);
            }
            return false;
        };

        return _;
    } ();


    let addSvg = function (parent) {
        let fixedUpperLeft = { position: "absolute", top: 0, left: 0 };
        //let backgroundColor = "#ddfaff";
        let backgroundColor = "#fff8dd";
        let divRoot = Builder
            .begin ("div", { style: { position: "relative", width: "100%", height: "100%", background: backgroundColor } })
            .begin ("http://www.w3.org/2000/svg;svg", {
                id: parent.id + "-svg-root",
                attributes: { width: "100%", height: "100%" },
                style: fixedUpperLeft
            })
            .begin ("http://www.w3.org/2000/svg;g", { id: parent.id + "-root-g" })
            .begin ("http://www.w3.org/2000/svg;g", { id: parent.id + "-view-g" })
            .add ("http://www.w3.org/2000/svg;g", {
                id: parent.id + "-client-g",
                attribute: { transform: "scale (1, -1)" }
            })
            .end ()
            .end ()
            .end ()
            .begin("div", { style: fixedUpperLeft })
            .add ("div", { id: parent.id + "-zoom-div", style: { padding: "1px 3px" } })
            .end ()
            .end ();
        parent.appendChild (divRoot);

        let svgRoot = document.getElementById (parent.id + "-svg-root");
        let rootG = document.getElementById (parent.id + "-root-g");
        let viewG = document.getElementById (parent.id + "-view-g");
        let clientG = document.getElementById (parent.id + "-client-g");
        viewG.appendChild(clientG);

        // add event handlers
        svgRoot.addEventListener("mousedown", function (event) { this.svgTransformer.handleSvgMouseDown (event); }, false);
        svgRoot.addEventListener("mouseup", function (event) { this.svgTransformer.handleSvgMouseUp (event); }, false);
        svgRoot.addEventListener("mousemove", function (event) { this.svgTransformer.handleSvgMouseMove (event); }, false);
        svgRoot.addEventListener("wheel", function (event) { this.svgTransformer.handleSvgWheel (event); }, false);

        // set up the view scales
        let bound = svgRoot.getBoundingClientRect ();
        let rootScale = Math.min (bound.width, bound.height);
        let translateX = bound.width / (2 * rootScale);
        let translateY = bound.height / (2 * rootScale);
        rootG.setAttribute ("transform", "scale(" + rootScale + ") translate(" + translateX + "," + translateY + ")");

        // create a transformer object to manipulate the view
        svgRoot.svgTransformer = SvgTransformer.new ({ parentId: parent.id, view: viewG, rootScale: rootScale });
        svgRoot.svgTransformer.setTransform();
        return clientG;
    };

    let parent = document.getElementById("parent");
    let svgClient = addSvg(parent);

    let drawLine = function (container, a, b, color, alpha, width) {
        container.appendChild(Builder
            .add ("http://www.w3.org/2000/svg;line", {
                attributes: {
                    "x1": a.x, "y1": a.y,
                    "x2": b.x, "y2": b.y,
                    "stroke": color,
                    "opacity": alpha,
                    "stroke-width": width,
                    "stroke-linecap":"round"
                }
            }));
    };

    let drawPath = function (container, points, color, alpha, width) {
        let path = "M " + points[0].x + " " + points[0].y + " ";
        for (let i = 1; i < points.length; ++i) {
            path += "L " + points[i].x + " " + points[i].y + " ";
        }
        container.appendChild (Builder
            .add ("http://www.w3.org/2000/svg;path", {
                attributes: {
                    "d": path,
                    "stroke": color,
                    "opacity": alpha,
                    "stroke-width": width,
                    "stroke-linecap": "round",
                    "fill": "transparent"
                }
            }));
    };

    let smoothPath = function (pointsIn, pass) {
        // function to create a new point between b and c that splits the difference
        let subdivideSegment = function (a, b, c, d) {
            let halfStepLength = function (a, b) {
                let d = { x: b.x - a.x, y: b.y - a.y };
                return Math.sqrt((d.x * d.x) + (d.y * d.y));
            };
            let halfStep = function (a, b, scale) {
                let d = halfStepLength(a, b);
                return { x: b.x + (((b.x - a.x) / d) * scale), y: b.y + (((b.y - a.y) / d) * scale) };
            };

            let abLength = halfStepLength(a, b);
            let dcLength = halfStepLength(d, c);
            let scale = Math.min (abLength, dcLength) / 5;
            let ab = halfStep(a, b, scale);
            let dc = halfStep(d, c, scale);
            return { x: (ab.x + dc.x) / 2, y: (ab.y + dc.y) / 2 };
        };

        // function to reflect b across a
        let reflectPoint = function (a, b) {
            return { x: a.x + (a.x - b.x), y: a.y + (a.y - b.y) };
        };

        // create a copy of the points we can manipulate
        let points = pointsIn.slice(0);
        let n = points.length - 1;
        points.unshift(reflectPoint(points[0], points[1]));
        points.push(reflectPoint(points[n], points[n - 1]));

        let smoothedPoints = [];
        for (let i = 1; i <= n; ++i) {
            smoothedPoints.push (points[i]);
            let newPoint = subdivideSegment(points[i - 1], points[i], points[i + 1], points[i + 2]);
            smoothedPoints.push (newPoint);
        }
        smoothedPoints.push (points[n + 1]);

        // keep going?
        return (--pass > 0) ? smoothPath (smoothedPoints, pass) : smoothedPoints;
    };

    let perturbPath = function (points, perturbDelta) {
        let perturbPoint = function (pt) {
            return {
                x: pt.x + (((Math.random () * 2) - 1) * perturbDelta),
                y:pt.y + (((Math.random () * 2) - 1) * perturbDelta)
            };
        };
        // randomly perturb each of the points
        let perturbedPoints = [];
        for (let point of points) {
            perturbedPoints.push (perturbPoint(point));
        }
        return perturbedPoints;
    };

    let drawWiggleLine = function (container, a, b, color, alpha, width, perturbDelta, parts) {
        // split the line into parts
        let delta = { x: b.x - a.x, y: b.y - a.y };
        let deltaLength = Math.sqrt ((delta.x * delta.x) + (delta.y * delta.y));
        let points = [a];

        for (let i = 1; i < parts; ++i) {
            let d = deltaLength * (i / parts);
            let point = { x: a.x + (d * delta.x), y: a.y + (d * delta.y)};
            points.push(point);
        }
        points.push(b);

        points = perturbPath (points, perturbDelta);
        points = smoothPath(points, 2);
        drawPath (container, points, color, alpha, width);
    };

    // make graph paper, 100x100 grid
    let gridG = Builder.add ("http://www.w3.org/2000/svg;g");
    let gridAlpha = 0.1;
    let gridWeight = 0.002;
    drawLine (gridG, {x: -1, y: 0}, {x: 1, y: 0}, "#00f", gridAlpha * 2, gridWeight * 2);
    drawLine (gridG, {x: 0, y: -1}, {x: 0, y: 1}, "#00f", gridAlpha * 2, gridWeight * 2);
    let gridSize = 50;
    for (let i = 1; i <= gridSize; ++i) {
        let val = i / gridSize;
        drawLine (gridG, {x: -1, y: val}, {x: 1, y: val}, "#08f", gridAlpha, gridWeight);
        drawLine (gridG, {x: -1, y: -val}, {x: 1, y: -val}, "#08f", gridAlpha, gridWeight);
        drawLine (gridG, {x: val, y: -1}, {x: val, y: 1}, "#08f", gridAlpha, gridWeight);
        drawLine (gridG, {x: -val, y: -1}, {x: -val, y: 1}, "#08f", gridAlpha, gridWeight);
    }
    //svgClient.appendChild(gridG);

    let drawMove = function (container, scale, move, drawInto) {
        let offsetBase = 0.035;
        let offset = {
            x: ((Math.random() * 2) - 1) * offsetBase,
            y: ((Math.random() * 2) - 1) * offsetBase
        };
        let scaleOffset = 3 + (((Math.random() * 2) - 1) * 0.1);
        let rotate = ((Math.random() * 2) - 1) * 6; // degrees

        let y = (Board.DIMENSION - 1) - move.y ();
        let xG = Builder.add ("http://www.w3.org/2000/svg;g", { attribute: {
                transform: "translate(" + ((move.x () + offset.x) / 3) + "," + ((y + offset.y) / 3) + ") scale (" + (1 / scaleOffset) + ") rotate (" + rotate + ")"
            } });
        drawInto (xG);
        container.appendChild (xG);
    };

    let drawX = function (container, scale, move) {
        let xColor = "#fab";
        drawMove (container, scale, move, function (xG) {
            drawWiggleLine (xG, { x: 0.25, y: 0.25 }, { x: 0.75, y: 0.75 }, xColor, 1.0, 0.075, 0.015, 3);
            drawWiggleLine (xG, { x: 0.25, y: 0.75 }, { x: 0.75, y: 0.25 }, xColor, 1.0, 0.075, 0.015, 3);
        });
    };

    Math.TWO_PI = Math.PI * 2;
    let drawO = function (container, scale, move) {
        let oColor = "#9af";
        drawMove (container, scale, move, function (xG) {
            let posFromAngle = function (angle) {
                return { x: (Math.cos(angle) / 4) + 0.5, y: (Math.sin (angle) / 4) + 0.5 };
            };
            let segmentCount = 8;
            let segmentAngle = Math.TWO_PI / segmentCount;
            let startAngle = Math.TWO_PI * Math.random();
            let points = [];
            for (let i = 0; i <= segmentCount; ++i) {
                let pos = posFromAngle(startAngle + (segmentAngle * (i % segmentCount)));
                points.push (pos);
            }

            points = perturbPath (points, 0.005);
            points = smoothPath(points, 2);
            drawPath (xG, points, oColor, 1.0, 0.075);
        });
    };

    let drawBoard = function (container, board, scale, location) {
        let boardColor = "#3cb";
        let boardWeight = 0.03;
        let boardVariance = 0.01;
        let boardG = Builder.add ("http://www.w3.org/2000/svg;g", { attribute: {
            transform: "translate(" + location.x + "," + location.y + ") scale (" + scale + ")"
        } });
        drawWiggleLine (boardG, { x: 0, y: 0.333 }, { x: 1, y: 0.333 }, boardColor, 1.0, boardWeight, boardVariance, 8);
        drawWiggleLine (boardG, { x: 0, y: 0.667 }, { x: 1, y: 0.667 }, boardColor, 1.0, boardWeight, boardVariance, 8);
        drawWiggleLine (boardG, { x: 0.333, y: 0 }, { x: 0.333, y: 1 }, boardColor, 1.0, boardWeight, boardVariance, 8);
        drawWiggleLine (boardG, { x: 0.667, y: 0 }, { x: 0.667, y: 1 }, boardColor, 1.0, boardWeight, boardVariance, 8);

        // now add the board positions
        for (let row = 0; row < Board.DIMENSION; ++row) {
            for (let col = 0; col < Board.DIMENSION; ++col) {
                let move = Move.get (col, row);
                let player = board.getPlayer (move);
                switch (player) {
                    case Player.X:
                        drawX (boardG, scale, move);
                        break;
                    case Player.O:
                        drawO (boardG, scale, move);
                        break;
                    default:
                        break;
                }
            }
        }

        container.appendChild (boardG);
    };

    let wins = Referee.getWins();
    let halfWins = wins.length / 2;
    let size = 0.15;
    let spacingScale = 1.5;
    let spacing = size * spacingScale;
    for (let i = 0; i < halfWins; ++i) {
        drawBoard (svgClient, Board.fromString (wins[i]), size, { x: -1 + (i * spacing), y: 0 });
        drawBoard (svgClient, Board.fromString (wins[i + halfWins]), size, { x: -1 + (i *spacing), y: spacing });
    }

</script>
